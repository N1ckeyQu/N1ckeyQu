{"meta":{"title":"曲颀的Blog","subtitle":"放下焦虑，安心生活","description":"湖南工业大学19级，记录生活，聊点技术","author":"N1ckeyQu","url":"http://cookiez.cn","root":"/"},"pages":[{"title":"关于我","date":"2021-05-16T07:34:51.000Z","updated":"2021-05-16T07:36:26.487Z","comments":true,"path":"aboutMe/index.html","permalink":"http://cookiez.cn/aboutMe/index.html","excerpt":"","text":"base杭州Java development engineerDestiny 2 player(AFK)&#78;&#x31;&#99;&#107;&#x65;&#121;&#81;&#x75;&#x40;&#49;&#54;&#x33;&#x2e;&#x63;&#x6f;&#109;放下焦虑，安心生活"},{"title":"分类","date":"2021-05-16T07:21:44.000Z","updated":"2021-05-16T07:25:37.439Z","comments":true,"path":"category/index.html","permalink":"http://cookiez.cn/category/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-05-16T07:21:31.000Z","updated":"2021-05-16T07:25:16.654Z","comments":true,"path":"tag/index.html","permalink":"http://cookiez.cn/tag/index.html","excerpt":"","text":""}],"posts":[{"title":"放下面子","slug":"放下面子","date":"2021-08-09T17:07:22.000Z","updated":"2021-08-09T17:22:04.805Z","comments":true,"path":"2021/08/10/放下面子/","link":"","permalink":"http://cookiez.cn/2021/08/10/%E6%94%BE%E4%B8%8B%E9%9D%A2%E5%AD%90/","excerpt":"","text":"入行快两年了，技术方面还是差了很多，想做点有意义的事，能力不够，咋办？干就完了 面子 VS 项目进度上午主要在看粤海水务那边将两个PCM文件合并成一个WAV文件的ffmpeg命令，方法是现成的，但是具体使用还有些问题，比如文件应该存放在哪里，以及删除多余的参数等 下午阅读RPA需求，然后听产品讲需求，这次的RPA中控台还是跟AICC比较像，感觉真正有难度的地方还是creator和worker，我们中控台更多的是做权限管理和一些增删改查的操作。然后开始看哲如报过来的指令配置相关bug，这个需求我当时做的其实就有点懵，它允许你在指令配置中去配置一些变量，然后人机交互的过程中去由算法去获取到这个变量相关的值，我们拿到值以后，就可以在后续的对话中去使用 比如AI问我，你是哪里人？我说我是杭州人，假如我们在指令配置中添加了${城市}这个变量，此时后台已经拿到了用户所在的地址，就可以应用在后续的对话里面 这个功能还是挺复杂的，对于这种深层次的复杂逻辑我确实做的不好，当时很多地方都是孙哥指导我写的，我大概率无法独立完成这个功能。当时代码写晕了，忘记多轮对话这里也要加逻辑，才有了今天这个bug 其实今天孙哥已经让我别管这个bug了，他来解决，但是我当时陷入了一种很奇怪的心态，我觉得当时这个功能是我负责的，我要负责到底。但是我尝试解决之后，发现并没有完全解决。当时应该果断去做粤海水务的，和面子相比，项目的进度要重要得多","categories":[{"name":"日记","slug":"日记","permalink":"http://cookiez.cn/categories/%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"日记","slug":"日记","permalink":"http://cookiez.cn/tags/%E6%97%A5%E8%AE%B0/"}]},{"title":"初识MyCat","slug":"初识MyCat","date":"2021-05-26T06:45:08.000Z","updated":"2021-05-30T07:32:16.930Z","comments":true,"path":"2021/05/26/初识MyCat/","link":"","permalink":"http://cookiez.cn/2021/05/26/%E5%88%9D%E8%AF%86MyCat/","excerpt":"","text":"在mycat中配置分片规则，Java程序查询数据的时候，就可以不需要关心要查哪个库，而是专心写SQL即可","categories":[],"tags":[]},{"title":"API管理工具的对比","slug":"API管理工具的对比","date":"2021-05-25T06:31:34.000Z","updated":"2021-05-26T06:51:29.367Z","comments":true,"path":"2021/05/25/API管理工具的对比/","link":"","permalink":"http://cookiez.cn/2021/05/25/API%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E7%9A%84%E5%AF%B9%E6%AF%94/","excerpt":"","text":"由于PC后台管理系统之前由一名工程师独立开发，因此项目文档几乎为0。随着用户数量的不断增加，DB层的压力也越来越大，用户数量也即将突破500万，预计到了年底用户数量会到达千万级，分库分表势在必行 但分库分表的前提是先把业务理清楚，由于文档的缺失，很多业务逻辑就连项目的开发者本身都忘记了，因此重新梳理业务逻辑的第一步，就是引入一个好用的API管理工具 没有最好的，只有最合适的纵观目前市面上的API管理工具，最终遴选出：Knife4j、Apizza、YApi，这三者各有优劣，这里简单分析一下 Knife4j Apizza YApi 是否收费 ❌ 小型团队（2人或以下）免费（功能受限），更大型的团队需要收费（功能完整） ❌ 是否开源 ✔ 阉割版是开源的，收费的版本闭源 ✔ 实现原理 在swagger基础上，提供了定制的web页面，更符合国人习惯 Apizza是一个独立的项目，专门用于API的管理，官方提供有偿的私有部署的服务 YApi是一个独立的项目，可单独部署在远程服务器，专门用于API的管理 文档地址 knife4j (xiaominfo.com) Apizza 帮助中心 (teambition.com) YApi-教程 (baidu.com) 上述表格是一个简单的横向对比，我们再来详细看看它们的优劣 Knife4j在很早之前它其实不叫Knife4j，叫做swagger-bootstrap-ui，顾名思义，其实就是将swagger原生的页面进行了替换，更符合国人的阅读习惯 优势随着Knife4j作者不断的更新迭代，Knife4j也越来越强大，不仅仅是基于swagger，它还在swagger的基础上做了一系列的增强，包括但不限于： i18n国际化：接口文档支持中英文 访问页面加权控制：外部人员不知道用户名和密码，无法查看接口文档的web页面 生产环境屏蔽资源：生产环境屏蔽所有swagger相关资源 API全局搜索 支持接口mock 易于维护：凡是跟API文档有关的工作，维护必然是关键性的。假设我们有很多的API请求参数都用到了实体A，但梳理业务之后，我们发现实体A中的n个属性是没有必要传入的，将实体A中无用的n个属性删掉即可，接口文档会自动更新，不需要再去一个个的手动维护 等等一系列增强功能，作为一款不收费的开源软件，我觉得它的功能还是很强大的 劣势 侵入性强：Knife4j底层最终还是依赖的是swagger，它基于注解，因此对于我们接口本身具有很强的侵入性，如果我们想要预先生成请求报文，需要在请求报文对应的实体类上加入对应的注解，因此对实体类本身也有侵入 YApiYApi是去哪儿的研发团队做出来的一款API管理工具，它跟swagger没有任何关系，因此它不会对我们的API造成入侵，而且它的权限做的比较到位，便于团队管理。和Knife4j相比，它更加重量级，因为它已经是一个单独的项目了，专门用于管理API 优势 完善的权限管理 支持内网部署，部署流程简单 代码侵入性为0 支持高级mock 劣势 项目较重：体量相比于knife4j更重，由于是一个独立的项目，需要专门部署在内网中 学习成本略高：由于是一个单独的项目，且完成度很高，因此开发人员需要付出一定的时间去学习和适应 不易维护：假设我们有很多的API请求参数都用到了实体A，但梳理业务之后，我们发现实体A中的n个属性是没有必要传入的，将实体A中无用的n个属性删掉还不够，我们还需要去手动的修改YApi中涉及到实体A的API的请求报文 Apizza整体风格仿照Postman实现，易于上手，并且在生成接口文档方面进行了优化，可以在文档之间复用公共资源。一处定义，全局使用，同步更新，缺点是收费 优势 整体风格仿照Postman，学习成本低 文档之间复用公共资源 模型定义 模型绑定 假设我们有很多的API请求参数都用到了实体A，但梳理业务之后，我们发现实体A中的n个属性是没有必要传入的，将实体A中无用的n个属性删掉之后，再更新下Apizza中的模型A的定义就可以了，不需要再去修改一个个的API文档（前提是你的报文已经绑定了模型A） 劣势收费","categories":[],"tags":[]},{"title":"admin模块的拆分","slug":"工程拆分和技术改造","date":"2021-05-18T03:21:52.000Z","updated":"2021-05-21T05:03:49.909Z","comments":true,"path":"2021/05/18/工程拆分和技术改造/","link":"","permalink":"http://cookiez.cn/2021/05/18/%E5%B7%A5%E7%A8%8B%E6%8B%86%E5%88%86%E5%92%8C%E6%8A%80%E6%9C%AF%E6%94%B9%E9%80%A0/","excerpt":"","text":"admin模块的拆分逻辑背景：目前三套系统的代码，都写在一个工程中，需进行系统拆分，为后续实现微服务做出铺垫 剥离原有工程构想 admin模块剥离出来后，形成一个多模块项目。项目模块如下: admin-api 存放controller层的内容、jsp页面和一些静态资源 admin-service 存放service接口和serviceImpl admin-mapper 存放dao层接口和对应的mapper.xml文件 admin-common 存放实体类、工具类等等，其它模块都会用到的内容就放在该模块下 后续如果我们需要加gateway等等，在目前的工程结构基础上，添加新的模块 搭建工程结构，配置pom文件 模块之间的依赖关系如下：api -&gt; service -&gt; mapper -&gt; common 将公共资源（如：工具类、实体类等）放入common模块 剥离完成后，如果工程可以跑通，进行下一步 实现经过2天的时间，admin工程成功的被剥离出来。剥离过程本身难度并不高，主要就是把一些相关的文件copy到新工程对应的模块下，以及一些命名规范和包名的修改 难点admin工程本身虽然技术栈已然落后于市场的主流，但是其业务体量、技术栈的数量都不是小数目，因此整个剥离过程中，主要有以下难点： 不确定剥离业务的完成程度 由于老工程中混杂了三套系统的代码，因此想要做到完美的admin工程剥离，需要删掉一些无用的业务代码。而删除业务代码的前提是，我们需要懂业务 admin工程剥离完成后，需要确认所有的开放API都可用 很尴尬的是，admin工程当初是由一个人独立完成的，所以我们是没有测试用例的，一个都没有… 经过我自己手动测试（点点点），地区推广中涉及到了一张被删除的表，以及几个NPE，算是初步完成了测试 解决针对以上难点，解决方案如下： 开始着手梳理业务流程，从mapper层倒推controller层，判断哪些业务代码是无用的。每删除一段业务代码，需要手动测试这一块的对应功能（没什么难度，是个细活） 业务梳理完成后，进行一次完整的测试（不包括性能测试） 踩坑昨天志超在做文件导出的功能，我才发现原来daemon模块也是需要迁移的，所以周五开始梳理daemon模块 升级spring boot","categories":[{"name":"工作记录","slug":"工作记录","permalink":"http://cookiez.cn/categories/%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://cookiez.cn/tags/%E6%8A%80%E6%9C%AF/"},{"name":"架构升级","slug":"架构升级","permalink":"http://cookiez.cn/tags/%E6%9E%B6%E6%9E%84%E5%8D%87%E7%BA%A7/"}]},{"title":"RabbitMQ的使用场景","slug":"RabbitMQ的使用场景","date":"2021-05-05T07:07:22.000Z","updated":"2021-05-16T07:46:08.843Z","comments":true,"path":"2021/05/05/RabbitMQ的使用场景/","link":"","permalink":"http://cookiez.cn/2021/05/05/RabbitMQ%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/","excerpt":"bl商业地产管理系统是专门面向bl集团的，一个集团再大又能有多少人呢？其实在我看来很多架构都是多余的，但这也是没办法的事情，老旧的技术适应不了当今的市场，技术的迭代速度太快 当然，客户也很精明，这个系统后续能不能进行升级？一下子把路堵死了。只有把这些数据服务提供出去，作为一个能力、一种资产，客户才会去接受这个东西，这就是当今的市场","text":"bl商业地产管理系统是专门面向bl集团的，一个集团再大又能有多少人呢？其实在我看来很多架构都是多余的，但这也是没办法的事情，老旧的技术适应不了当今的市场，技术的迭代速度太快 当然，客户也很精明，这个系统后续能不能进行升级？一下子把路堵死了。只有把这些数据服务提供出去，作为一个能力、一种资产，客户才会去接受这个东西，这就是当今的市场 为什么要使用RabbitMQ刚进入公司的时候，公司项目的架构还比较单一，采用的是单体式架构。单体式架构是把所有的业务都堆积在一个项目里面，但是随着我们公司业务的不断发展和推进，CTO的目标是把项目架构进行拆分，变成分布式架构 项目架构的拆分就涉及到一个问题，比如员工出差申请报销，申请报销后需要给员工发送短信和邮件，三者需要进行沟通和协同，因此我们公司采用了消息队列 常见的消息队列有以下几种 ActiveMQ 老牌的消息中间件，遵循JMS规范、AMQP协议，基于Java开发，虽然跨平台是个好处，但我们更倾向于高性能 相对于业界其它MQ而言，它的复杂程度较高 RabbitMQ 跟Spring师出同门，因此Spring对它的支持很完善。它支持的协议、消息的分发策略、消息持久化等等也很完善 Kafka 它的吞吐量太高了，因为它底层是基于TCP/IP这种二进制协议开发的，我们用不到这么高的性能 RocketMQ RocketMQ挺牛逼的，双十一都能抗住，它由阿里和滴滴联合开发，但我担心的是，如果他们后续不对RocketMQ进行维护了怎么办？就比如Eureka和Ribbon，它们都已经停止维护了，但是据我的了解，目前仍然有不少企业依然在使用它们，我们又要保证现有服务的可用，同时又要进行架构的升级和转型，这就很难搞 经过一番权衡，最终我们选择了使用RabbitMQ，我个人使用RabbitMQ的感受，最核心的一点就是它是异步的，因为它起了多个线程，是一个异步分发消息的机制，程序处理数据的能力变得更加高效和稳健，达到了我们进行流量削峰的目的 RabbitMQ的使用场景解耦、异步、削峰之前我们聊到消息中间件存在的意义，它对于我们的分布式架构天然进行了解耦，它就是为此而生的。那异步又是怎么回事呢？ 串行执行假设我们的系统中存在订单服务，用户下订单后，我们不光要收费，还要通过短信和邮件的方式告知用户您的订单已经下好了 如果我们选择串行执行的话，假设发短信需要100ms，发邮件需要100ms，由于串行执行是阻塞的，因此整个程序执行完毕需要200ms 如果我们按照图中的异步来做，也就是非阻塞的，那么我们的程序只需要100ms就可以执行完毕，性能提升了50% 线程池？的确，线程池可以实现上述操作，通讯方面我们可以使用Socket来做，不一定非要使用MQ，但是这种做法有如下几种问题 消息的可靠性（订单服务突然挂掉，消息是否会丢失？） 针对这种情况，我们需要做消息的持久化，也就是消息存盘，需要NIO、BIO、AIO相关的知识 高可用（一个线程池的能力终究是有限的，能否做集群？） 不光是集群，还有线程池的调优，这也是个头疼的问题 解耦（线程池和订单服务的代码是耦合的，如何保证Java虚拟机内存不被过多占用、以及项目的可维护性？） 针对上面这些问题，其实如果系统的流量比较低倒也没啥，流量一上来，问题就来了。数据服务作为一种资产，什么叫资产，资产是可以保值的。所以直接上MQ，一步到位，省的后续又要升级架构，客户难道会为我们的架构升级买单吗？不可能的","categories":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://cookiez.cn/categories/RabbitMQ/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://cookiez.cn/tags/%E6%8A%80%E6%9C%AF/"},{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://cookiez.cn/tags/RabbitMQ/"},{"name":"中间件","slug":"中间件","permalink":"http://cookiez.cn/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"}]},{"title":"RabbitMQ的核心组件","slug":"RabbitMQ的核心组件","date":"2021-05-04T06:45:05.000Z","updated":"2021-05-16T07:46:41.661Z","comments":true,"path":"2021/05/04/RabbitMQ的核心组件/","link":"","permalink":"http://cookiez.cn/2021/05/04/RabbitMQ%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/","excerpt":"RabbitMQ的本质就是消息队列，其内部结构包括交换机、路由key、bindings、队列等组件","text":"RabbitMQ的本质就是消息队列，其内部结构包括交换机、路由key、bindings、队列等组件 Server：又称为broker，接受客户端的连接，实现AMQP实体服务。安装rabbitmq-server。我们可以将其理解为RabbitMQ集群中的一个节点 Connection：连接，用于应用程序和broker的网络连接，其本质是TCP/IP的三次握手和四次挥手 Channel：网络信道，几乎所有RabbitMQ的操作都在Channel中进行，Channel是进行消息读写的通道，客户端可以建立多个Channel，每个Channel代表一个会话任务 Message：应用程序之间所传递的消息，由Properties和Body组成，Properties可以对消息进行修饰，比如消息的优先级、延迟等高级特性，Body则是消息体的内容 Virtual Host：虚拟地址，用于进行逻辑隔离，一个虚拟主机里可以有若干个Exchange和Queue，同一个虚拟主机里不能有相同名字的Exchange 它就好比我们的硬盘分区，之所以进行硬盘分区的原因就是为了隔离，方便我们管理。实际工作中，通常是一个业务模块一个虚拟地址，比如客流模块就是/passengerFlow，车流模块就是/carFlow，方便我们查看 Exchange：交换机，接受消息，根据路由key发送消息到绑定的队列 注意：交换机本身不具备消息存储的能力 Bindings：Exchange和Queue之间的虚拟连接，binding中可以包含多个key Routing key：是一个路由规则，虚拟机可以用它来确定如何路由一个特定消息 Queue：队列，也叫Messge Queue，消息队列，它保存消息并将消息转发给消费者 面试题：可以存在没有交换机的队列吗？ 不可能。如果我们没有给队列指定交换机，那么该队列将会和默认交换机绑定。在RabbitMQ中，消息一定是通过交换机传递给队列的，这个和底层语言的选择有关，RabbitMQ由Erlang开发，而Erlang是专门开发交换机的语言 交换机的几种类型 fanout：发布订阅模式。当交换机接收到消息并发布，交换机绑定了多少个队列，就有多少个队列接受到该消息 direct：路由模式。当交换机绑定队列时，可设置路由key。当交换机发布消息的时候，选择想要将消息发送给哪个路由key，该路由器对应的队列就会收到消息 topic：主题模式。其实就是路由模式的进阶版，我们在设置路由key的时候，还可以加上通配符，比如：*.order.# 通配符有两种，*和#。*的意思是有且只能有一级，com.order.lala这种是对的，cn.com.order.lala这种就不对了，因为order前面只能有一级 #的意思是可以有一级、多级，也可以没有。比如com.order，或者com.order.lala.lala，都可以 header：参数模式。 当交换机和队列绑定时，可以绑定一些参数，当header类型的交换机发送消息时，选择我们想要发送的参数，比如我们选择x=1和y=2 这条消息就会发送给queue1和queue2","categories":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://cookiez.cn/categories/RabbitMQ/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://cookiez.cn/tags/%E6%8A%80%E6%9C%AF/"},{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://cookiez.cn/tags/RabbitMQ/"},{"name":"中间件","slug":"中间件","permalink":"http://cookiez.cn/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"}]},{"title":"消息队列的高可用","slug":"消息队列的高可用","date":"2021-05-02T04:44:05.000Z","updated":"2021-05-16T07:50:48.656Z","comments":true,"path":"2021/05/02/消息队列的高可用/","link":"","permalink":"http://cookiez.cn/2021/05/02/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8/","excerpt":"","text":"所谓高可用，是指系统在正常工作时间内提供正常服务的能力。当业务量膨胀时，请求数量也不断增长，一台消息中间件服务器会达到硬件（CPU、硬盘、内存）的极限，一台满足不了业务需求，那就上消息中间件集群来实现高可用","categories":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://cookiez.cn/categories/RabbitMQ/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://cookiez.cn/tags/%E6%8A%80%E6%9C%AF/"},{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://cookiez.cn/tags/RabbitMQ/"},{"name":"中间件","slug":"中间件","permalink":"http://cookiez.cn/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"}]},{"title":"消息的分发策略","slug":"消息的分发策略","date":"2021-05-02T03:50:02.000Z","updated":"2021-05-16T07:50:16.848Z","comments":true,"path":"2021/05/02/消息的分发策略/","link":"","permalink":"http://cookiez.cn/2021/05/02/%E6%B6%88%E6%81%AF%E7%9A%84%E5%88%86%E5%8F%91%E7%AD%96%E7%95%A5/","excerpt":"MQ有以下几个核心： 生产者 存储消息 消费者 本文我们重点关注MQ是如何将消息传递给消费者的，一般而言数据的传递无非就是两种形式，推和拉，比如git。假设此时APP端传来了一个创建订单的请求，MQ会对消息进行一个分发，这当中不仅仅是只有推和拉那么简单，这涉及到了MQ的分发策略","text":"MQ有以下几个核心： 生产者 存储消息 消费者 本文我们重点关注MQ是如何将消息传递给消费者的，一般而言数据的传递无非就是两种形式，推和拉，比如git。假设此时APP端传来了一个创建订单的请求，MQ会对消息进行一个分发，这当中不仅仅是只有推和拉那么简单，这涉及到了MQ的分发策略 ActiveMQ RabbitMQ Kafka RocketMQ 发布订阅 支持 支持 支持 支持 轮询分发 支持 支持 支持 - 公平分发 - 支持 支持 - 重发 支持 支持 - 支持 消息拉取 - 支持 支持 支持 发布订阅 类比公众号，假设公众号A有1000人订阅，当该公众号发布了一条新的文章，这1000人都会收到该文章的推送。也就是说，MQ收到了消息，会将其分发给所有消费者 轮询分发 &amp; 公平分发 轮询分发是指，假设我们现在有三个消费者，此时MQ要分发三条消息，假设消费者A所在的server响应时间为2000ms，消费者B所在的server响应时间为100ms，消费者C所在的server响应时间为500ms，不论服务器的性能如何，这三条消息会公平的分发给消费者，不会进行任何的数据倾斜 如果是公平分发，上述的分发结果可能是A收到0条消息，B收到2条消息，C收到1条消息，该策略会进行数据的倾斜，能者多劳。注意，该策略只支持手动应答，不支持自动应答 它们的共同点：如果一条消息已经被某个消费者消费了，那么该消息不可能再被其它消费者进行重复消费 重发 从分发消息到消费者返回结果给MQ，这个过程中可能会出现异常、出现网络抖动、宕机等情况，导致消息无法被消费。比如用户请求查询客流数据，此时客流模块挂了，导致用户查询客流数据失败 此时消息中间件就需要支持消息重试的策略，说白了，就是系统出现问题的情况下，消息保证不丢失并且还可以支持重发 消息拉取 根据RPC机制实现，很少使用MQ来做消息拉取","categories":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://cookiez.cn/categories/RabbitMQ/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://cookiez.cn/tags/%E6%8A%80%E6%9C%AF/"},{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://cookiez.cn/tags/RabbitMQ/"},{"name":"中间件","slug":"中间件","permalink":"http://cookiez.cn/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"}]},{"title":"基于消息中间件的分布式系统架构","slug":"基于消息中间件的分布式系统架构","date":"2021-05-02T03:21:52.000Z","updated":"2021-05-16T07:48:54.574Z","comments":true,"path":"2021/05/02/基于消息中间件的分布式系统架构/","link":"","permalink":"http://cookiez.cn/2021/05/02/%E5%9F%BA%E4%BA%8E%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/","excerpt":"分布式架构中，一个系统由若干个子系统构成，因此系统与系统之间的通讯就显得很重要了","text":"分布式架构中，一个系统由若干个子系统构成，因此系统与系统之间的通讯就显得很重要了 基于消息中间件的分布式架构 从上图中我们可以看到，消息中间件最根本的功能就是通讯，实现通信就需要遵守通信协议。通信协议有很多，比如TCP/IP协议、HTTP协议、AMQP、OpenMessage协议等，我们应该选择哪种呢？ 其次，消息中间件需要具备高可用（持久化、集群），比如消息中间件刚收到消息后就宕机了，等待服务器恢复正常后，消息中间件是否还能够进行正常的消息分发呢？ 然后，消息中间件还需要能给将消息分发给消费者，这就涉及到了分发策略的选择，是发布订阅模式？还是公平模式？还是轮询模式？ 并且，消息中间件需要做到跨平台，不管我们的业务模块是用什么语言编写的，消息中间件都要能够支持 消息中间件所应该具备的能力 跨系统数据传递 高并发情况的流量削峰 数据的分发和异步处理 大数据分析和传递 分布式事务 比如我们有一个数据要进行迁移或者请求并发过多的时候，假设我们现在有10w的并发请求下订单，我们可以在这些订单入库之前，将这批订单请求堆积到消息队列中，让它稳健可靠的入库和执行 常见的消息中间件 ActiveMQ RabbitMQ Kafka RocketMQ 消息中间件的本质接收数据、存储数据、发送数据 消息中间件的组成部分 消息的协议（TCP/IP、UDP、AMQP、MQTT、Kafka协议、OpenMessage协议等） 所谓的协议是指： 计算机OS和应用程序通讯时所共同遵守的约定，只有遵循共同的约定和规范，应用和底层操作系统之间才能相互交流 网络协议的要素 语法：数据的结构与格式，以及数据出现的顺序 语义：解释数据中每个部分的含义，它规定了我们需要发出怎样的数据，以及发送完成后的动作和返回怎样的响应 时序：对事件发生顺序的详细说明 以http协议为例： 语法：http规定了请求报文和响应报文的格式 语义：客户端主动发起请求才称之为请求 时序：一个请求对应一个响应，先有请求再有响应 那为什么消息中间件的协议不直接使用http协议呢？ 因为http请求报文头和响应报文头是比较复杂的，包含cookie、响应码、状态码等附加功能，但是这些东西对于消息中间件来说完全没用，它只需要负责数据的接收、存储、分发，它追求的是高性能、高可用，因此消息中间件所使用的协议一定要简洁、高效 大部分情况下http请求都是短链接，在实际交互过程中，客户端发起请求到响应结果返回，这个过程很可能会中断，中断以后不会进行持久化，就会造成消息的丢失，这对于消息中间件来说是不可接受的。 因为消息中间件所面临的场景是接收、存储、发送消息，这是一个长期的过程，中间出现问题的话，消息中间件需要对消息进行持久化等操作，保证消息的可靠 ps：短链接就是用户发起请求，此时服务器故障，则请求直接丢失，并不会维持客户端和服务端的链接；长链接就是当服务器出现故障，重启之后依然可以进行数据的传递，从而维持长久的关系 消息的持久化机制 ActiveMQ RabbitMQ Kafka RocketMQ 文件存储 √ √ √ √ 数据库 √ - - - 消息的分发策略 高可用、扩展性 消息的容错机制","categories":[{"name":"中间件","slug":"中间件","permalink":"http://cookiez.cn/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://cookiez.cn/tags/%E6%8A%80%E6%9C%AF/"},{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://cookiez.cn/tags/RabbitMQ/"},{"name":"中间件","slug":"中间件","permalink":"http://cookiez.cn/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"}]},{"title":"浅谈中间件技术及其架构","slug":"浅谈中间件技术及其架构","date":"2021-05-01T12:43:10.000Z","updated":"2021-05-16T07:48:34.439Z","comments":true,"path":"2021/05/01/浅谈中间件技术及其架构/","link":"","permalink":"http://cookiez.cn/2021/05/01/%E6%B5%85%E8%B0%88%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%8A%80%E6%9C%AF%E5%8F%8A%E5%85%B6%E6%9E%B6%E6%9E%84/","excerpt":"中间件技术非常的多，但大体分为： 分布式消息中间件 负载均衡中间件 缓存中间件 数据库中间件","text":"中间件技术非常的多，但大体分为： 分布式消息中间件 负载均衡中间件 缓存中间件 数据库中间件 下面我们简单来看一看 分布式消息中间件 ActiveMQ 遵循JMS规范、AMQP协议的消息中间件，使用Java语言开发，老牌的分布式消息中间件 但相对于业界其它的MQ而言，复杂程度较高 RabbitMQ 目前很流行的消息中间件，它支持的协议、分发的模式、持久化等等是比较完善的。并且它和Spring师出同门，因此Spring对RabbitMQ的支持比较完善 Kafka 高性能消息中间件的代言人，它是基于TCP/IP这种二进制的协议来开发的，所以它的性能非常高，因为它最接近底层 不支持事务，但支持持久化和部分分发机制 RocketMQ 阿里、滴滴联合开发的国产消息队列 支持事务 使用场景 消息中间件监控场景 异步数据传输场景 削峰填谷场景 任务调度场景 海量数据同步场景 分布式事务场景 大数据分析场景 协议之前我们了解到，中间件的特点：要遵守协议（为了传输数据）、持久化（高可用）、扩展性（做集群）等等。这里我们来看看消息中间件要遵循哪些协议 AMQP MQTT Kafka协议 OpenMessage 我们不是有TCP/IP协议、UDP协议吗，为什么还要搞这么多协议出来 因为TCP/IP协议无法满足我们的需求，所以我们在TCP/IP协议基础之上重新构建了一些内容，就成了上述协议。注意，这些协议的底层仍然是TCP/IP协议 负载均衡中间件 Nginx（重点） LVS负载均衡中间件 KeepAlive CDN（重点） 缓存中间件 MemCache 将缓存数据写在代码中，因此会占用JVM的内存，小型项目适用 Redis（重点） 分布式架构下，缓存中间件的首选 数据库中间件MySQL天然支持持久化，但它并不具备高可用（因为MySQL本身不支持集群），如果我们要实现MySQL的集群以及分库分表，需要使用如下的第三方中间件，实现MySQL的高可用 MyCat ShardingJDBC 单体式架构 vs 分布式架构对于早期的单体式应用来说，所有的业务模块、所有的源代码、静态资源文件都放在同一个工程中，其中一个模块做了很小的改动，就需要重新编译和部署整个项目。随着业务不断膨胀，它的问题暴露如下： 耦合度高 维护性差 后续架构升级的难度大 基于以上的种种问题，我们引入了分布式架构 单体式应用中，一个请求由一个系统处理。而在分布式架构中，一个请求由服务端的多个服务协同处理完成 它的问题如下： 学习成本高 运维成本和服务器成本高 系统的可用性虽然提升，但面临的错误也会成倍增加 基于安全性的考虑，迫使我们选择RMI/MQ来进行服务器之间的通讯 好处： 可以合理的分配服务器资源，减少了服务器资源的浪费 各个模块可以独立的维护和部署，降低耦合度，不会造成整个平台因部署而造成的停服状态 系统的架构和技术栈变得灵活（除了Java，我们还可以选择python和Golang） 谁更好？没有最好的架构，只有最合适的架构","categories":[{"name":"中间件","slug":"中间件","permalink":"http://cookiez.cn/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://cookiez.cn/tags/%E6%8A%80%E6%9C%AF/"},{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://cookiez.cn/tags/RabbitMQ/"},{"name":"中间件","slug":"中间件","permalink":"http://cookiez.cn/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"}]},{"title":"中间件是什么","slug":"中间件是什么","date":"2021-05-01T11:13:10.000Z","updated":"2021-05-16T07:52:16.334Z","comments":true,"path":"2021/05/01/中间件是什么/","link":"","permalink":"http://cookiez.cn/2021/05/01/%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88/","excerpt":"什么是中间件？我们为什么要学习中间件？ 由于一些历史原因，企业中可能运行着不同的业务系统，这些系统可能基于不同的OS、不同的DB、甚至不同的语言。如何将这些不同的系统构建成一个整体，形成真正的跨平台、分布式应用，中间件就是解决之道，它用自己的复杂换取了构建企业应用的简单","text":"什么是中间件？我们为什么要学习中间件？ 由于一些历史原因，企业中可能运行着不同的业务系统，这些系统可能基于不同的OS、不同的DB、甚至不同的语言。如何将这些不同的系统构建成一个整体，形成真正的跨平台、分布式应用，中间件就是解决之道，它用自己的复杂换取了构建企业应用的简单 假设由于历史原因，企业中有这样三个模块，它们分别由不同的语言构建，如果我们想要将它们构成一个整体，首先跨模块的交互是必然的 协议 我们知道，通讯是要遵循协议的，这个协议可以是TCP/IP、UDP，也可以是在它们的基础之上构建的一些协议。比如：AMQP、MQTT、OpenMessage等等 高可用 假设我们的消息刚刚传递到中间件，结果中间件所在的服务器宕机了，导致消息丢失。这个消息如果是一笔金额很大的订单，那就是很严重的事故了，所以，我们必须要保证中间件的高可用 持久化是个不错的选择，消息传到中间件之后，将消息进行持久化，即便服务器宕机，也不会丢失数据。除此之外，我们也可以通过集群的方式来保证高可用。当然，集群必然会带来数据的一致性问题，这个以后再说 理论听的很多了，那到底什么是中间件呢 其实中间件是很常见的，有些可能我们已经用过了，只是我们尚未意识到它就是中间件。比如：MySQL、Redis、Nginx、MQ等等，它们都是中间件 比如MySQL，我们通过Java应用往数据库中存储数据时，我们并不需要直接和硬盘进行交互，而是由MySQL代劳，我们将数据基于某种通信协议（比如TCP/IP）传给MySQL，再由MySQL完成数据的持久化工作 为什么要使用中间件中间件屏蔽了OS底层的复杂性，使得开发人员面对简单而统一的开发环境，减少程序设计的复杂性，将注意力更多的集中在业务上，不必再为程序在不同系统上的移植而重复工作，减少开发工作量 中间件的特点 遵循通信协议 高可用 高性能 什么情况下在项目中应用中间件技术无论是项目的架构和重构中，对于任何技术和架构的改变我们都需要谨慎斟酌和思考。因为任何技术或架构的变化都可能导致人力成本、技术负债、学习成本的增加。中间件技术一般在互联网公司应用较多，如果我们仅仅只是一个初创公司，最多加个缓存中间件即可，不要盲目的追求所谓的新技术或者所谓的高性能，试想你的系统根本就没多少流量进来，为什么要上大规模的kafka集群呢？ 追求新技术的背后，必然是业务的驱动和项目的驱动，因为一旦决定追求新技术，就意味着开发人员的学习成本、公司的人力成本、服务器成本、技术负债、运维成本等增加，一定要谨慎","categories":[{"name":"中间件","slug":"中间件","permalink":"http://cookiez.cn/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://cookiez.cn/tags/%E6%8A%80%E6%9C%AF/"},{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://cookiez.cn/tags/RabbitMQ/"},{"name":"中间件","slug":"中间件","permalink":"http://cookiez.cn/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"}]},{"title":"浅谈Java内存模型","slug":"浅谈Java内存模型","date":"2021-05-01T08:43:10.000Z","updated":"2021-05-16T07:47:58.563Z","comments":true,"path":"2021/05/01/浅谈Java内存模型/","link":"","permalink":"http://cookiez.cn/2021/05/01/%E6%B5%85%E8%B0%88Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/","excerpt":"Java内存模型是什么？为什么Java官方要引入Java内存模型？","text":"Java内存模型是什么？为什么Java官方要引入Java内存模型？ JMM我们平时所使用的硬件和操作系统可能是不同的，这导致了相同的代码在不同的环境上执行会产生不同的结果。Java官方为了屏蔽掉硬件不同和os不同所带来的访问内存差异，引入了Java内存模型——JMM，从而实现Java程序在全平台一致的并发效果 Java内存模型 Java内存模型规定，所有的成员变量（实例变量和静态变量）都保存在主内存中，但线程不能直接对主内存中的变量进行操作 每个线程都有自己的工作内存，如果线程需要操作共享数据，需要先将数据从主内存读取并copy到自己的工作内存中，然后再对工作内存中的副本进行操作 不同线程之间是不可见的，即线程A无法访问线程B的工作内存。如果线程之间需要进行变量值的传递，需要经过主内存来完成 注意：Java内存模型和JVM内存结构是两个截然不同的概念，如果我们一定要去类比的话，主内存对应堆内存中的对象实例数据部分，线程工作内存对应虚拟机栈中的部分区域 由JMM引申出的八种操作 JMM定义了什么开篇我们提过，JMM的引入目的就是为了屏蔽掉硬件和OS不同所带来的内存访问差异，从而使得Java程序在全平台都拥有相同的并发性能。Java并发编程的基础：原子性、可见性、有序性，这三个特点，也是JMM的核心特征 原子性一个操作时不可分割的、不会被打断的。一个线程在执行时不会被其它线程打断 可见性当一个线程修改了共享变量的值后，其它线程立刻知道该共享变量被修改了，这就是可见性。Java为我们提供了volatile关键字来实现可见性，被volatile修饰的变量被修改后，该变量会被立刻刷新到主内存中，当其它线程需要修改该变量时，必须从主内存中获取该变量最新的值。普通变量是不能保证每次都走上述流程的 当然，除了volatile之外，final和synchronized也可以实现可见性 final关键字修饰的变量，一旦初始化完成，且没有对象逸出，那么对于其它线程就是可见的 synchronized修饰的代码，执行完后，进入unlock前，必须要将共享变量同步到主内存中 有序性synchronized和volatile都可以实现有序性 synchronized保证有序性的原理是：一个线程lock后，必须进行unlock操作；然后其它线程才可以lock，这就保证了synchronized修饰的代码在多线程环境下是串行执行的 volatile则是通过内存屏障来禁止指令重排序，从而保证有序性","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://cookiez.cn/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://cookiez.cn/tags/%E6%8A%80%E6%9C%AF/"},{"name":"Java基础","slug":"Java基础","permalink":"http://cookiez.cn/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"不懂生活的小孩","slug":"不懂生活的小孩","date":"2021-04-25T05:19:10.000Z","updated":"2021-05-16T07:52:45.918Z","comments":true,"path":"2021/04/25/不懂生活的小孩/","link":"","permalink":"http://cookiez.cn/2021/04/25/%E4%B8%8D%E6%87%82%E7%94%9F%E6%B4%BB%E7%9A%84%E5%B0%8F%E5%AD%A9/","excerpt":"","text":"一转眼已经从4月初到了4月底，离开上海也有近一个月了。离职第二天把房间退掉之后，我把三大包行李寄回了家，在郑州倒了一次车，傍晚到家之后，老妈居然去新疆了。。这么多年家中只有我一个人的情况，还是第一次遇到 姑姑知道我回来了，专门给我送了一碗馄饨过来。其实那天晚上我心里就已经有答案了，一定不能再独自生活了，人是群居动物，孤独会让人变得扭曲 清明去陵园看了看爷爷，自从陵园着火之后，那里进行了翻新工作，从原来的玻璃格子变成了木制的密封格子，纸钱也由焚化炉统一进行焚烧。变化还是有的，奶奶三年没去了，刚好我又回了邯郸，就陪奶奶和姑姑走了一趟 祭拜之后，回到家和奶奶闲聊，隐约透露出我不喜欢上海的工作，但终究没敢告诉奶奶实话，其实我已经从上海的公司离职了。在亲人面前，有些话是不太好说出口 不知不觉，自己已经快到25岁了。但是去奶奶家吃饭的时候，感觉我还是和以前一样，是那个需要别人照顾的孩子。奶奶这么想是习惯使然，我自己由于这么多年被照顾习惯了，其实我是不怎么懂生活、不会照顾自己的。所以在生活面前，我的确还是个小孩子。我不会做饭，面对着空空如也的冰箱一筹莫展，出来工作一年半了，这些基本的事情还不会，让我有点失落 南下短暂的清明假期结束，家庭确实是每个人最坚强的后盾，我的心气逐渐提了起来，心态也变得平和。经过再三思考，还是决定不留在老家，南下杭州。4月6号深夜，终于到了滨江和丁唐岳会合。暂住在这里。比自己一个人住强太多了，能有个陪你说话的人，才有家的感觉。虽然是睡沙发，但这两天我休息的很好，如果工作允许，我想和他们一起合租下去。 抉择转眼已经是4月底了，共收获了两家offer，都是15k，最低标准公积金。第一家是做车联网的，长期和传统车企合作，当时去面试聊的挺好的，当时工作环境感觉有些压抑，决定放弃；第二家是做背调业务，这个业务方向我还是挺看好的，但是最低标准缴纳公积金很不利于我长期在杭州发展，先把offer接了，继续面","categories":[{"name":"随笔","slug":"随笔","permalink":"http://cookiez.cn/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://cookiez.cn/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"人生中第一场葬礼","slug":"人生中第一场葬礼","date":"2020-12-09T06:04:05.000Z","updated":"2021-05-16T07:54:05.484Z","comments":true,"path":"2020/12/09/人生中第一场葬礼/","link":"","permalink":"http://cookiez.cn/2020/12/09/%E4%BA%BA%E7%94%9F%E4%B8%AD%E7%AC%AC%E4%B8%80%E5%9C%BA%E8%91%AC%E7%A4%BC/","excerpt":"这周二的晚上我从上海坐高铁回到老家，朋友D的父亲去世了，这是我人生中的第一场葬礼","text":"这周二的晚上我从上海坐高铁回到老家，朋友D的父亲去世了，这是我人生中的第一场葬礼 人的一生有许多的第一次，不知不觉我也到了参加葬礼的年纪了，时间过的真快。我跟D初中的时候就认识了，关系非常好，他父亲我见过两次，一次是初中的时候，当时我去D家找他，碰见伯伯了。我第一眼的感觉就是，D跟他爸简直是一个模子里刻出来的，太像了。当时问了好之后，跟伯伯就没有什么过多的交流了。他的话不多，我也是个不会说话的，没有什么客套寒暄的，第一次见面就这样结束了。 当时初中开家长会，我爸去了，当时我考了班里的中等水平，D倒数。我爸回来的时候脸色不太好看。我以为是我考的成绩差了要骂我。结果他问我是不是经常跟D玩，我说是啊。我爸说刚才D父亲发火了，说让他管管他家孩子，以后少跟他儿子玩，别耽误他家儿子学习……现在想想其实也是挺有意思的，家长会过去之后我跟D都没把家长的话当回事，照样去网吧玩。说起来，我人生中第一次去网吧，就是我D带我去的。从这个角度看，其实我中考成绩不好还是要怪他，哈哈。 第二次见面是高中时候的事情了，当时放假了，我找D去网吧打游戏，又碰见他父亲了，跟上次一样，问了好就没有多说什么了。那个时候年纪小，赶着去网吧打游戏，哪顾得上那几句话的功夫，一心都想着打游戏去了，不曾想却是最后一次见面。 周三上午，我和朋友L、G一同去往殡仪馆，上午10点悼念仪式正式开始。我们几个第一次参加葬礼，一些规矩都不懂，只好跟着大部队走，别人干啥我们就干啥。到了礼堂门口，戴上白花三鞠躬、默哀，然后集体瞻仰遗容。伯伯的帽子遮住了大半的脸，只能看到一部分侧脸，脸上没有皱纹，睡得很安详。转完半圈后跟D握手，他的手特别凉，可能体温都被眼泪带走了，那一刻我才接受了伯伯去世这个事实。 遗体火化之后，我们一起吃了顿饭。下午把骨灰送进陵园，去D家探望了一下伯母，我一个外人不好说什么，简单问候了几句，看见伯母精神状态还好，我朋友的负担应该也会小一点吧","categories":[{"name":"随笔","slug":"随笔","permalink":"http://cookiez.cn/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://cookiez.cn/tags/%E9%9A%8F%E7%AC%94/"}]}],"categories":[{"name":"日记","slug":"日记","permalink":"http://cookiez.cn/categories/%E6%97%A5%E8%AE%B0/"},{"name":"工作记录","slug":"工作记录","permalink":"http://cookiez.cn/categories/%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BD%95/"},{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://cookiez.cn/categories/RabbitMQ/"},{"name":"中间件","slug":"中间件","permalink":"http://cookiez.cn/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"Java基础","slug":"Java基础","permalink":"http://cookiez.cn/categories/Java%E5%9F%BA%E7%A1%80/"},{"name":"随笔","slug":"随笔","permalink":"http://cookiez.cn/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"日记","slug":"日记","permalink":"http://cookiez.cn/tags/%E6%97%A5%E8%AE%B0/"},{"name":"技术","slug":"技术","permalink":"http://cookiez.cn/tags/%E6%8A%80%E6%9C%AF/"},{"name":"架构升级","slug":"架构升级","permalink":"http://cookiez.cn/tags/%E6%9E%B6%E6%9E%84%E5%8D%87%E7%BA%A7/"},{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://cookiez.cn/tags/RabbitMQ/"},{"name":"中间件","slug":"中间件","permalink":"http://cookiez.cn/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"Java基础","slug":"Java基础","permalink":"http://cookiez.cn/tags/Java%E5%9F%BA%E7%A1%80/"},{"name":"随笔","slug":"随笔","permalink":"http://cookiez.cn/tags/%E9%9A%8F%E7%AC%94/"}]}